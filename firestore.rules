rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Helper function to check if user is admin
    // Note: This requires the user to be able to read their own document
    // We use isOwner check first to avoid circular dependency
    function isAdmin() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             // Use isOwner to ensure user can read their own document
             request.auth.uid != null &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }
    
    // Users collection
    match /users/{userId} {
      // Users can always read their own data (needed for isAdmin() to work)
      // Admins can read any user document (including list queries)
      // For list queries: Firestore evaluates this rule for each document
      // - Own document: isOwner allows it
      // - Other documents: isAdmin() checks if current user is admin
      // Using isAdmin() helper simplifies the rule and works better for list queries
      allow read: if isOwner(userId) || isAdmin();
      
      // Users can create their own user document
      allow create: if isAuthenticated() && isOwner(userId);
      
      // Only admins can update user data (including admin status)
      allow update: if isAdmin();
      
      // Only admins can delete users
      allow delete: if isAdmin();
    }
    
    // Chat sessions collection
    match /chatSessions/{sessionId} {
      // Users can read their own sessions
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Users can create their own sessions
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      
      // Users can update their own sessions
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Users can delete their own sessions
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }
    
    // Avatars collection
    match /avatars/{avatarId} {
      // Public avatars: all authenticated users can read
      // Private avatars: only creator can read
      // Admins can read any avatar
      allow read: if isAuthenticated() && 
                     (resource.data.isPublic == true || 
                      resource.data.createdBy == request.auth.uid || 
                      isAdmin());
      
      // Any authenticated user can create avatars
      // Must set createdBy to their own uid
      // Exception: Allow create without createdBy if document doesn't exist
      // (handles set() with merge on deleted documents - ownership enforced on update)
      allow create: if isAuthenticated() && 
                     (request.resource.data.createdBy == request.auth.uid ||
                      // If document doesn't exist, allow create (for status updates on deleted docs)
                      // Update rule will enforce ownership if document exists
                      !exists(/databases/$(database)/documents/avatars/$(avatarId)));
      
      // Users can update avatars they created, or admins can update any
      // When using set() with merge, if document exists, this rule applies
      allow update: if isAuthenticated() && 
                     (resource.data.createdBy == request.auth.uid || isAdmin());
      
      // Users can delete avatars they created, or admins can delete any
      allow delete: if isAuthenticated() && 
                     (resource.data.createdBy == request.auth.uid || isAdmin());
    }
    
    // Categories collection - for organizing avatars
    match /categories/{categoryId} {
      // All authenticated users can read categories
      allow read: if isAuthenticated();
      
      // Only admins can create/update/delete categories
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Expressions collection
    match /expressions/{expressionId} {
      // All authenticated users can read expressions
      allow read: if isAuthenticated();
      
      // Only admins can create expressions
      allow create: if isAdmin();
      
      // Only admins can update expressions
      allow update: if isAdmin();
      
      // Only admins can delete expressions
      allow delete: if isAdmin();
    }
    
    // Admin collection - for storing admin configuration
    match /admin/{documentId} {
      // Only admins can read admin documents
      allow read: if isAdmin();
      
      // Only admins can create admin documents
      allow create: if isAdmin();
      
      // Only admins can update admin documents
      allow update: if isAdmin();
      
      // Only admins can delete admin documents
      allow delete: if isAdmin();
    }
    
    // Training videos collection - for storing training videos with active/inactive status
    match /trainingVideos/{videoId} {
      // All authenticated users can read training videos (needed for AI generation)
      allow read: if isAuthenticated();
      
      // Only admins can create training videos
      allow create: if isAdmin();
      
      // Only admins can update training videos
      allow update: if isAdmin();
      
      // Only admins can delete training videos
      allow delete: if isAdmin();
    }
    
    // Subscription packages collection
    match /subscriptionPackages/{packageId} {
      // All authenticated users can read packages (to see available subscriptions)
      // This allows both individual document reads and list queries
      allow read: if isAuthenticated();
      
      // Only admins can create/update/delete packages
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // User subscriptions collection
    match /userSubscriptions/{subscriptionId} {
      // Users can read their own subscriptions (allows list queries with userId filter)
      // Admins can read any subscription
      allow read: if isAuthenticated() && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      
      // Users can create their own subscriptions (after payment)
      // Must set userId to their own uid
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      
      // Users can update their own subscriptions, admins can update any
      allow update: if isAuthenticated() && 
                       (resource.data.userId == request.auth.uid || isAdmin());
      
      // Only admins can delete subscriptions
      allow delete: if isAdmin();
    }
    
    // Payments collection - track one-time payments for avatar creation
    match /payments/{paymentId} {
      // Users can read their own payments (allows list queries with userId filter)
      // Admins can read any payment
      allow read: if isAuthenticated() && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      
      // Users can create their own payment records
      // Must set userId to their own uid
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      
      // Only admins can update/delete payments (payment records should be immutable)
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Credit configurations collection - admin configurable credit costs
    match /creditConfig/{configId} {
      // All authenticated users can read credit configurations
      allow read: if isAuthenticated();
      
      // Only admins can create/update/delete credit configurations
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Credit purchases collection - track credit purchases
    match /creditPurchases/{purchaseId} {
      // Users can read their own credit purchases
      // Admins can read any purchase
      allow read: if isAuthenticated() && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      
      // Users can create their own purchase records (after Stripe payment)
      // Must set userId to their own uid
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      
      // Only admins can update/delete purchases
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Credit transactions collection - track all credit deductions/additions
    match /creditTransactions/{transactionId} {
      // Users can read their own credit transactions
      // Admins can read any transaction
      allow read: if isAuthenticated() && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      
      // Only server/system can create credit transactions (via admin functions)
      // Users cannot directly create transactions
      allow create: if isAdmin();
      
      // Only admins can update/delete transactions
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Credit packages collection - configurable credit packages for purchase
    match /creditPackages/{packageId} {
      // All authenticated users can read active credit packages
      allow read: if isAuthenticated() && 
                     (resource.data.active == true || isAdmin());
      
      // Only admins can create/update/delete credit packages
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}
